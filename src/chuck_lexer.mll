(*
Lexer for the Chuck language

Adapted from lex file by:
  Ge Wang (gewang.cs.princeton.edu) - generated by lex
  Perry R. Cook (prc@cs.princeton.edu)

Adaptation to OCaml 2017

*)

{
  open Batteries
  open Lexing
  open Pd_parser


 (* In comments, the name in the original lex file *)
  let digit = ['0'-'9'] (* D *)
  let letter = ['a'-'z' 'A'-'Z'] (* L *)
  let hexa_d = ['a'-'f' 'A'-'F' digit] (* H *)
  let octa_d = ['0'-'7']
  let exp = ['e' 'E'] ['-' '+']? digit+ (* E *)
  let fs = 'f' | 'F' | 'l' | 'L' (* FS *) (* Float qualifier? *)
  let is  = ('u' | 'U' | 'l' | 'L')* (* IS *) (* Unsigned and long qualifiers? *)

  let white = [' ' '\t']+
  let newline = '\r' | '\n' | "\r\n"

  let hexa = '0' ['x' 'X'] hexa_d+ is?
  let octal = '0' ['c' 'C'] octa_d+ is?
  let int = digit+ is?
  let float = (digit+"."digit*)|(digit*"."digit+)

  let id = letter [letter digit]*

(* Common module for tools for lexing and parsing? And error with message but also position? *)
exception SyntaxError of string

let next_line lexbuf =
  let pos = lexbuf.lex_curr_p in
  lexbuf.lex_curr_p <-
    { pos with pos_bol = lexbuf.lex_curr_pos;
               pos_lnum = pos.pos_lnum + 1
    }


let format_pos_error lexbuf =
  let pos = lexbuf.lex_curr_p in
    "line " ^ string_of_int pos.pos_lnum ^ " character " ^ string_of_int (pos.pos_cnum - pos.pos_bol + 1)

}

(*******************************************************************************)
(************************* Start of regular expressions ************************)
(*******************************************************************************)

rule read =
  parse
  | "//"                    { c_comment lexbuf }
  (* | "<--"                   { char c;  comment_hack; continue; } *) (* Do not seem to be actually used *)
  | "/*"                    { block_comment lexbuf }
  | white                   { read lexbuf }
  | newline                 { next_line lexbuf; read lexbuf }

  | "++"                    {   PLUSPLUS }
  | "--"                    {   MINUSMINUS }
  | "#("                    {   POUNDPAREN }
  | "%("                    {   PERCENTPAREN }
  | "@("                    {   ATPAREN }
  |
  | ","                     {   COMMA }
  | ":"                     {   COLON }
  | "."                     {   DOT }
  | "+"                     {   PLUS }
  | "-"                     {   MINUS }
  | "*"                     {   TIMES }
  | "/"                     {   DIVIDE }
  | "%"                     {   PERCENT }
  | "#"                     {   POUND }
  | "$"                     {   DOLLAR }
  |
  | "::"                    {   COLONCOLON }
  | "=="                    {   EQ }
  | "!="                    {   NEQ }
  | "<"                     {   LT }
  | ">"                     {   GT }
  | "<="                    {   LE }
  | ">="                    {   GE }
  | "&&"                    {   AND }
  | "||"                    {   OR }
  | "&"                     {   S_AND }
  | "|"                     {   S_OR }
  | "^"                     {   S_XOR }
  | ">>"                    {   SHIFT_RIGHT }
  | "<<"                    {   SHIFT_LEFT }
  | "="                     {   ASSIGN }
  | "("                     {   LPAREN }
  | ")"                     {   RPAREN }
  | "["                     {   LBRACK }
  | "]"                     {   RBRACK }
  | "{"                     {   LBRACE }
  | "}"                     {   RBRACE }
  | ""                      {   SEMICOLON }
  | "?"                     {   QUESTION }
  | "!"                     {   EXCLAMATION }
  | "~"                     {   TILDA }
  | "for"                   {   FOR }
  | "while"                 {   WHILE }
  | "until"                 {   UNTIL }
  | "repeat"                {   LOOP }
  | "continue"              {   CONTINUE }
  | "break"                 {   BREAK }
  | "if"                    {   IF }
  | "else"                  {   ELSE }
  | "do"                    {   DO }
  | "<<<"                   {   L_HACK }
  | ">>>"                   {   R_HACK }


  | "function"              {   FUNCTION }
  | "fun"                   {   FUNCTION }
  | "new"                   {   NEW }
  | "class"                 {   CLASS }
  | "interface"             {   INTERFACE }
  | "extends"               {   EXTENDS }
  | "implements"            {   IMPLEMENTS }
  | "public"                {   PUBLIC }
  | "protected"             {   PROTECTED }
  | "private"               {   PRIVATE }
  | "static"                {   STATIC }
  | "pure"                  {   ABSTRACT }
  | "const"                 {   CONST }
  | "spork"                 {   SPORK }
  | "typeof"                {   TYPEOF }

  | "=>"                    {   CHUCK }
  | "=<"                    {   UNCHUCK }
  | "!=>"                   {   UNCHUCK }
  | "=^"                    {   UPCHUCK }
  | "@=>"                   {   AT_CHUCK }
  | "+=>"                   {   PLUS_CHUCK }
  | "-=>"                   {   MINUS_CHUCK }
  | "*=>"                   {   TIMES_CHUCK }
  | "/=>"                   {   DIVIDE_CHUCK }
  | "&=>"                   {   S_AND_CHUCK }
  | "|=>"                   {   S_OR_CHUCK }
  | "^=>"                   {   S_XOR_CHUCK }
  | ">>=>"                  {   SHIFT_RIGHT_CHUCK }
  | "<<=>"                  {   SHIFT_LEFT_CHUCK }
  | "%=>"                   {   PERCENT_CHUCK }
  | "@"                     {   AT_SYM }
  | "@@"                    {   ATAT_SYM }
  | "->"                    {   ARROW_RIGHT }
  | "<-"                    {   ARROW_LEFT }

  | hexa as num             { NUM(int_of_string num) } (* Or use a long? *)
  | octa as num             { NUM(int_of_string num)}
  | int as num              { NUM(int_of_string num)}
  | float as num            { FLOAT(float_of_string num) }
  | id as ident             {  ID(ident) }
  | '\"'                    {  double_quote_string (Buffer.create 20) }
  | '`'                     {  single_quote_string (Buffer.create 20) }
  | ''' ('.'|[^ ''']) '''         { CHAR_LIT; }

  | _ { raise (SyntaxError ("Illegal string character: " ^ Lexing.lexeme lexbuf ^  " " ^ format_pos_error lexbuf ^ "\n") ) }
  | eof      { EOF }

and block_comment =
  parse
  | "*/"                    { read lexbuf }
  | newline                 {next_line lexbuf; block_comment lexbuf }
  | _                       { block_comment lexbuf }
  | eof                     { raise (SyntaxError "Eof in comment") }
and c_comment =
  parse
  | newline                 { next_line lexbuf; read lexbuf }
  | _                       { block_comment lexbuf }
  | eof                     { raise (SyntaxError "Eof in comment") }
and double_quote_string buffer =
  parse
  | '"' { STRING_LIT (Buffer.contents buffer) }
  | "\\t" { Buffer.add_char buffer '\t'; double_quote_string buffer lexbuf }
  | "\\n" { Buffer.add_char buffer '\n'; double_quote_string buffer lexbuf }
  | "\\n" { Buffer.add_char buffer '\n'; double_quote_string buffer lexbuf }
  | '\\' '"' { Buffer.add_char buffer '"'; double_quote_string buffer lexbuf }
  | '\\' '\\' { Buffer.add_char buffer '\\'; double_quote_string buffer lexbuf }
  | eof { raise (SyntaxError ("Illegal string character: " ^ Lexing.lexeme lexbuf ^  " " ^ format_pos_error lexbuf ^ "\n") ) }
  | _ as char { Buffer.add_char buffer char; double_quote_string buffer lexbuf }
 and simple_quote_string buffer =
  parse
  | ''' { STRING_LIT (Buffer.contents buffer) }
  | "\\t" { Buffer.add_char buffer '\t'; simple_quote_string buffer lexbuf }
  | "\\n" { Buffer.add_char buffer '\n'; simple_quote_string buffer lexbuf }
  | "\\n" { Buffer.add_char buffer '\n'; simple_quote_string buffer lexbuf }
  | '\\' '"' { Buffer.add_char buffer '"'; simple_quote_string buffer lexbuf }
  | '\\' '\\' { Buffer.add_char buffer '\\'; simple_quote_string buffer lexbuf }
  | eof { raise (SyntaxError ("Illegal string character: " ^ Lexing.lexeme lexbuf ^  " " ^ format_pos_error lexbuf ^ "\n") ) }
  | _ as char { Buffer.add_char buffer char; simple_quote_string buffer lexbuf }




{
(* Pretty printer *)

}
